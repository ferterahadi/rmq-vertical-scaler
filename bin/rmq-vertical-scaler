#!/usr/bin/env node

import { Command } from 'commander';
import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const packageJson = JSON.parse(readFileSync(join(__dirname, '../package.json'), 'utf-8'));

const program = new Command();

program
  .name('rmq-vertical-scaler')
  .description('Generate Kubernetes manifests for RabbitMQ Vertical Scaler\n\nCommon usage:\n  rmq-vertical-scaler generate --namespace prod --service-name my-rabbitmq\n  rmq-vertical-scaler generate --help  # See all customization options')
  .version(packageJson.version)
  .option('-n, --namespace <namespace>', 'Kubernetes namespace (shortcut for generate -n)')
  .option('-s, --service-name <name>', 'RabbitMQ service name (shortcut for generate -s)')
  .option('-o, --output <file>', 'Output file name (shortcut for generate -o)');

// Generate command
program
  .command('generate')
  .description('Generate Kubernetes deployment manifests for RabbitMQ Vertical Scaler')
  .option('-n, --namespace <namespace>', 'Kubernetes namespace where RabbitMQ and scaler will be deployed', 'default')
  .option('-s, --service-name <name>', 'Name of the RabbitMQ service/cluster (used for DNS and secrets)', 'rabbitmq')
  .option('-o, --output <file>', 'Output YAML file name for the generated manifests', 'rmq-scaler.yaml')
  .option('--image <image>', 'Docker image to use for the scaler deployment', 'ferterahadi/rabbitmq-scaler:latest')
  .option('--scaler-name <name>', 'Custom name for scaler resources (ServiceAccount, Role, etc.)', 'rmq-vertical-scaler')
  .option('--interactive', 'Run in interactive mode to customize scaling profiles and thresholds')
  .option('--low-cpu <cpu>', 'CPU request for LOW profile', '330m')
  .option('--low-memory <memory>', 'Memory request for LOW profile', '2Gi')
  .option('--medium-cpu <cpu>', 'CPU request for MEDIUM profile', '800m')
  .option('--medium-memory <memory>', 'Memory request for MEDIUM profile', '3Gi')
  .option('--high-cpu <cpu>', 'CPU request for HIGH profile', '1600m')
  .option('--high-memory <memory>', 'Memory request for HIGH profile', '4Gi')
  .option('--critical-cpu <cpu>', 'CPU request for CRITICAL profile', '2400m')
  .option('--critical-memory <memory>', 'Memory request for CRITICAL profile', '8Gi')
  .option('--medium-queue-threshold <num>', 'Queue depth to trigger MEDIUM profile', '2000')
  .option('--medium-rate-threshold <num>', 'Message rate to trigger MEDIUM profile', '200')
  .option('--high-queue-threshold <num>', 'Queue depth to trigger HIGH profile', '10000')
  .option('--high-rate-threshold <num>', 'Message rate to trigger HIGH profile', '1000')
  .option('--critical-queue-threshold <num>', 'Queue depth to trigger CRITICAL profile', '50000')
  .option('--critical-rate-threshold <num>', 'Message rate to trigger CRITICAL profile', '2000')
  .option('--scale-up-debounce <seconds>', 'Time to wait before scaling up (prevents oscillation)', '30')
  .option('--scale-down-debounce <seconds>', 'Time to wait before scaling down (prevents oscillation)', '120')
  .option('--check-interval <seconds>', 'How often to check metrics and make scaling decisions', '5')
  .action(async (options) => {
    try {
      await generateKubernetesManifests(options);
    } catch (error) {
      console.error('‚ùå Failed to generate manifests:', error.message);
      process.exit(1);
    }
  });

// Show help when no command is provided, or run generate if options are provided
program.action(async (options) => {
  // If user provided options, run generate with those options
  if (options.namespace || options.serviceName || options.output) {
    console.log('üîÑ Running generate command with provided options...\n');
    await generateKubernetesManifests({
      namespace: options.namespace || 'default',
      serviceName: options.serviceName || 'rabbitmq',
      output: options.output || 'rmq-scaler.yaml',
      image: 'ferterahadi/rabbitmq-scaler:latest',
      scalerName: 'rmq-vertical-scaler',
      lowCpu: '330m',
      lowMemory: '2Gi',
      mediumCpu: '800m',
      mediumMemory: '3Gi',
      highCpu: '1600m',
      highMemory: '4Gi',
      criticalCpu: '2400m',
      criticalMemory: '8Gi',
      mediumQueueThreshold: '2000',
      mediumRateThreshold: '200',
      highQueueThreshold: '10000',
      highRateThreshold: '1000',
      criticalQueueThreshold: '50000',
      criticalRateThreshold: '2000',
      scaleUpDebounce: '30',
      scaleDownDebounce: '120',
      checkInterval: '5'
    });
  } else {
    program.help();
  }
});

program.parse();

// Implementation functions
async function generateKubernetesManifests(options) {
  const { writeFileSync } = await import('fs');
  
  console.log('üîß Generating Kubernetes manifests...');
  console.log(`üìù Namespace: ${options.namespace}`);
  console.log(`üê∞ RabbitMQ Service: ${options.serviceName}`);
  console.log(`üì¶ Image: ${options.image}`);
  console.log(`üè∑Ô∏è  Scaler Name: ${options.scalerName}`);
  console.log('');
  console.log('üìä Scaling Profiles:');
  console.log(`  LOW:      CPU=${options.lowCpu}, Memory=${options.lowMemory}`);
  console.log(`  MEDIUM:   CPU=${options.mediumCpu}, Memory=${options.mediumMemory} (triggers at: ${options.mediumQueueThreshold} queue depth, ${options.mediumRateThreshold} msg/s)`);
  console.log(`  HIGH:     CPU=${options.highCpu}, Memory=${options.highMemory} (triggers at: ${options.highQueueThreshold} queue depth, ${options.highRateThreshold} msg/s)`);
  console.log(`  CRITICAL: CPU=${options.criticalCpu}, Memory=${options.criticalMemory} (triggers at: ${options.criticalQueueThreshold} queue depth, ${options.criticalRateThreshold} msg/s)`);
  console.log('');
  console.log('‚è±Ô∏è  Timing Configuration:');
  console.log(`  Scale Up Debounce: ${options.scaleUpDebounce}s`);
  console.log(`  Scale Down Debounce: ${options.scaleDownDebounce}s`);
  console.log(`  Check Interval: ${options.checkInterval}s`);
  
  // Generate the YAML content programmatically
  const manifest = generateManifestContent(options);
  
  writeFileSync(options.output, manifest);
  console.log('');
  console.log(`‚úÖ Generated ${options.output}`);
  console.log('');
  console.log('üìã Next steps:');
  console.log(`  1. Review the generated configuration`);
  console.log(`  2. Apply to your cluster: kubectl apply -f ${options.output}`);
  console.log(`  3. Monitor the deployment: kubectl logs -f deployment/${options.scalerName} -n ${options.namespace}`);
  console.log('');
  console.log('üí° To customize profiles further, use the options shown in --help');
  console.log('   Example: ./bin/rmq-vertical-scaler generate --medium-cpu 1000m --high-memory 6Gi');
}

function generateManifestContent(options) {
  const scalerName = options.scalerName || 'rmq-vertical-scaler';
  const serviceAccount = `${scalerName}-sa`;
  const role = `${scalerName}-role`;
  const roleBinding = `${scalerName}-binding`;
  const configMap = `${scalerName}-config`;
  const deployment = scalerName;
  const pdb = `${options.serviceName}-pdb`;
  
  return `---
# ServiceAccount for the scaler
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ${serviceAccount}
  namespace: ${options.namespace}
---
# Role for vertical scaling operations
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: ${role}
  namespace: ${options.namespace}
rules:
  - apiGroups: ['rabbitmq.com']
    resources: ['rabbitmqclusters']
    verbs: ['get', 'patch', 'update']
  - apiGroups: ['']
    resources: ['secrets']
    verbs: ['get']
  - apiGroups: ['']
    resources: ['configmaps']
    verbs: ['get', 'create', 'update', 'patch']
---
# RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ${roleBinding}
  namespace: ${options.namespace}
subjects:
  - kind: ServiceAccount
    name: ${serviceAccount}
    namespace: ${options.namespace}
roleRef:
  kind: Role
  name: ${role}
  apiGroup: rbac.authorization.k8s.io
---
# ConfigMap for scaler state tracking
apiVersion: v1
kind: ConfigMap
metadata:
  name: ${configMap}
  namespace: ${options.namespace}
data:
  stable_profile: ""
  stable_since: "0"
---
# PodDisruptionBudget to ensure only 1 pod scaling at a time
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: ${pdb}
  namespace: ${options.namespace}
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: ${options.serviceName}
---
# Deployment for the vertical scaler
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${deployment}
  namespace: ${options.namespace}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ${deployment}
  template:
    metadata:
      labels:
        app: ${deployment}
    spec:
      serviceAccountName: ${serviceAccount}
      containers:
        - name: scaler
          image: ${options.image}
          imagePullPolicy: Always
          resources:
            requests:
              cpu: 75m
              memory: 128Mi
            limits:
              cpu: 200m
              memory: 512Mi
          env:
            # RabbitMQ credentials from secret
            - name: RMQ_USER
              valueFrom:
                secretKeyRef:
                  name: ${options.serviceName}-default-user
                  key: username
            - name: RMQ_PASS
              valueFrom:
                secretKeyRef:
                  name: ${options.serviceName}-default-user
                  key: password
            # RabbitMQ connection settings
            - name: RMQ_HOST
              value: '${options.serviceName}.${options.namespace}.svc.cluster.local'
            - name: RMQ_PORT
              value: '15672'
            - name: RMQ_SERVICE_NAME
              value: '${options.serviceName}'
            # Dynamic resource names
            - name: CONFIG_MAP_NAME
              value: '${configMap}'
            # Profile configuration
            - name: PROFILE_COUNT
              value: '4'
            - name: PROFILE_NAMES
              value: 'LOW MEDIUM HIGH CRITICAL'
            # Profile resources
            - name: PROFILE_LOW_CPU
              value: '${options.lowCpu}'
            - name: PROFILE_LOW_MEMORY
              value: '${options.lowMemory}'
            - name: PROFILE_MEDIUM_CPU
              value: '${options.mediumCpu}'
            - name: PROFILE_MEDIUM_MEMORY
              value: '${options.mediumMemory}'
            - name: PROFILE_HIGH_CPU
              value: '${options.highCpu}'
            - name: PROFILE_HIGH_MEMORY
              value: '${options.highMemory}'
            - name: PROFILE_CRITICAL_CPU
              value: '${options.criticalCpu}'
            - name: PROFILE_CRITICAL_MEMORY
              value: '${options.criticalMemory}'
            # Scaling thresholds
            - name: QUEUE_THRESHOLD_MEDIUM
              value: '${options.mediumQueueThreshold}'
            - name: RATE_THRESHOLD_MEDIUM
              value: '${options.mediumRateThreshold}'
            - name: QUEUE_THRESHOLD_HIGH
              value: '${options.highQueueThreshold}'
            - name: RATE_THRESHOLD_HIGH
              value: '${options.highRateThreshold}'
            - name: QUEUE_THRESHOLD_CRITICAL
              value: '${options.criticalQueueThreshold}'
            - name: RATE_THRESHOLD_CRITICAL
              value: '${options.criticalRateThreshold}'
            # Debounce settings
            - name: DEBOUNCE_SCALE_UP_SECONDS
              value: '${options.scaleUpDebounce}'
            - name: DEBOUNCE_SCALE_DOWN_SECONDS
              value: '${options.scaleDownDebounce}'
            # Check interval
            - name: CHECK_INTERVAL_SECONDS
              value: '${options.checkInterval}'
      restartPolicy: Always`;
}